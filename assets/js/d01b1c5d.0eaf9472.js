"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[670],{4662:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var i=t(5893),o=t(1151);const s={title:"Tuning Client for Performance"},r=void 0,a={id:"guides/client-tuning",title:"Tuning Client for Performance",description:"HTTP (Hypertext Transfer Protocol)",source:"@site/docs/guides/client-tuning.md",sourceDirName:"guides",slug:"/guides/client-tuning",permalink:"/docs/guides/client-tuning",draft:!1,unlisted:!1,editUrl:"https://github.com/tailcallhq/tailcallhq.github.io/tree/develop/docs/guides/client-tuning.md",tags:[],version:"current",frontMatter:{title:"Tuning Client for Performance"},sidebar:"tutorialSidebar",previous:{title:"CLI",permalink:"/docs/guides/cli"},next:{title:"Context",permalink:"/docs/guides/context"}},c={},l=[{value:"HTTP (Hypertext Transfer Protocol)",id:"http-hypertext-transfer-protocol",level:3},{value:"HTTP Versions: 1.x, 2, and 3",id:"http-versions-1x-2-and-3",level:3},{value:"TCP (Transmission Control Protocol)",id:"tcp-transmission-control-protocol",level:3},{value:"QUIC (Quick UDP Internet Connections)",id:"quic-quick-udp-internet-connections",level:3},{value:"Why Managing Connections is Important?",id:"why-managing-connections-is-important",level:3},{value:"Tuning HTTP Client",id:"tuning-http-client",level:2},{value:"poolMaxIdlePerHost",id:"poolmaxidleperhost",level:3},{value:"tcpKeepAlive",id:"tcpkeepalive",level:3},{value:"connectTimeout",id:"connecttimeout",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h3,{id:"http-hypertext-transfer-protocol",children:"HTTP (Hypertext Transfer Protocol)"}),"\n",(0,i.jsx)(n.p,{children:"HTTP is like the most widely used protocol for communication between a client and a server. When you request a webpage, it's HTTP that carries your request to the server and then brings back the data to your client. HTTP is built on top of TCP."}),"\n",(0,i.jsx)(n.h3,{id:"http-versions-1x-2-and-3",children:"HTTP Versions: 1.x, 2, and 3"}),"\n",(0,i.jsx)(n.p,{children:"With each version, HTTP has become more flexible and performant."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"HTTP/1.x"}),": Each HTTP request creates separate TCP connection (or a sequentially reused one)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"HTTP/2"}),":\nIntroduces multiplexing, allowing multiple requests and responses to be sent concurrently over a single TCP connection, improving performance."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"HTTP/3"}),":\nUses QUIC instead of TCP, further reducing connection setup time and improving handling of packet loss and network changes."]}),"\n"]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The version of the HTTP is decided by the server. So if the server only supports HTTP/1 there is no way the client can make an HTTP/2 request, even if it's compatible. However if the client only supports HTTP/1 the server as per the spec should respect and downgrade itself to serve the request over HTTP/1."})}),"\n",(0,i.jsx)(n.h3,{id:"tcp-transmission-control-protocol",children:"TCP (Transmission Control Protocol)"}),"\n",(0,i.jsx)(n.p,{children:"TCP is the underlying protocol that makes sure the data sent and received over the internet reaches its destination correctly and in order."}),"\n",(0,i.jsxs)(n.p,{children:["Before any data can be exchanged using HTTP, TCP establishes a connection between the client and server, like dialing a number before talking on the phone. We will see how to tune Tailcall's HTTP client to improve the performance of this connection. You can learn more about TCP in detail ",(0,i.jsx)(n.a,{href:"https://www.techtarget.com/searchnetworking/definition/TCP",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"quic-quick-udp-internet-connections",children:"QUIC (Quick UDP Internet Connections)"}),"\n",(0,i.jsxs)(n.p,{children:["QUIC is a newer protocol developed by Google. It's designed to make web communications faster and more efficient compared to TCP. It reduces connection establishment time, is better at handling packet loss, and supports multiplexed streams over a single connection, which prevents one slow request from holding up others. It is the foundation for HTTP/3.\nYou can learn more about QUIC in detail ",(0,i.jsx)(n.a,{href:"https://blog.cloudflare.com/the-road-to-quic",children:"here"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"why-managing-connections-is-important",children:"Why Managing Connections is Important?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Performance Overhead"}),":\nEstablishing TCP connections, particularly in HTTP/1.x, can be time consuming due to the need for a complete TCP handshake for each new connection. This process adds latency and increase in system resources ."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Limited Ports on Client Side"}),":\nEach TCP connection from a client requires a unique combination of an IP address and a port number. With each new connection the IP remains the same because the client is the same, however a new port is used. The number of available ports on a machine is 65535, they are shared between all the processes and not all are available for usage. So this excessive creation of new connections ultimately leads to port exhaustion on the client side, preventing it from establishing new connections and causing system failures across the processes that are running on the system."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["You can check out the ports to process mapping using ",(0,i.jsx)(n.code,{children:"lsof"})," and ",(0,i.jsx)(n.code,{children:"netstat"})," commands."]})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Connection pooling helps mitigate the above issues by reusing existing connections for multiple requests. This reduces the frequency of connection establishments (and thus the handshake overhead) and also conserves client-side ports. This approach enhances application performance by minimizing the resources and time spent on managing connections."}),"\n",(0,i.jsx)(n.h2,{id:"tuning-http-client",children:"Tuning HTTP Client"}),"\n",(0,i.jsxs)(n.p,{children:["Tailcall by default uses connection pooling to manage connections and is setup with a default tuning which works well for most of the use cases. However, there are some cases where you might want to tune the HTTP client further to improve the performance of your application. Tailcall DSL provides an operator named ",(0,i.jsx)(n.a,{href:"/docs/operators/upstream",children:"@upstream"})," which can help you to tune the HTTP client."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"The connection pooling is only a meaning optimization when it comes to HTTP/1. Since HTTP/2 and HTTP/3 support multiplexing it's hard to see any observable difference in performance with pooling enabled."})}),"\n",(0,i.jsx)(n.p,{children:"When using HTTP/1.x, you can tune the connection pool by using the following parameters:"}),"\n",(0,i.jsx)(n.h3,{id:"poolmaxidleperhost",children:"poolMaxIdlePerHost"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"poolMaxIdlePerHost"})," is a setting that specifies the maximum number of idle connections allowed per host and defaults to ",(0,i.jsx)(n.code,{children:"60"}),". Example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:"schema\n  @upstream(\n    # highlight-start\n    poolMaxIdlePerHost: 60\n    # highlight-end\n  ) {\n  query: Query\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Keeping too many idle connections can unnecessarily tie up memory and ports, while too few might lead to delays as new connections have to be established frequently. By limiting the number of idle connections, ",(0,i.jsx)(n.code,{children:"poolMaxIdlePerHost"})," ensures that the system uses network and memory resources judiciously, avoiding wastage on connections that are rarely used."]}),"\n",(0,i.jsx)(n.p,{children:"If you have an application which connects to many hosts you should set this value to a lower number that way you will have connections available to connect to other hosts. On the other hand if you a few hosts and all requests have to be resolved by those hosts, you should keep a higher value for this setting."}),"\n",(0,i.jsx)(n.h3,{id:"tcpkeepalive",children:"tcpKeepAlive"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"tcpKeepAlive"})," is a setting that keeps TCP connections alive for the specified duration, especially during periods of inactivity. It periodically sends packets to the server to check if the connection is still open and functioning. In connection pooling, where you have a set of reusable connections, tcpKeepAlive helps in maintaining these connections in a ready-to-use state. It's particularly useful for long-lived connections in the pool. By ensuring these connections are still active, it prevents the client from attempting to use a connection that has been closed by the server due to inactivity. Without tcpKeepAlive, idle connections in the pool might get silently dropped by the server or intermediate network devices (like firewalls or load balancers). When your client tries to use such a dropped connection, it would fail, causing delays and errors. Keeping connections alive and monitored means you can efficiently reuse them, reducing the overhead of establishing new connections frequently."]}),"\n",(0,i.jsxs)(n.p,{children:["Tailcall provides a parameter named ",(0,i.jsx)(n.code,{children:"tcpKeepAlive"})," for the upstream which defaults to 5 seconds. Example:\nschema"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",children:"@upstream (\n# highlight-start\n  tcpKeepAlive: 300\n# highlight-end\n) {\nquery: Query\n}\n\n"})}),"\n",(0,i.jsx)(n.h3,{id:"connecttimeout",children:"connectTimeout"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"connectTimeout"})," is a specific kind of timeout that applies only to the phase where your client is trying to establish a connection with the server. When you make a connection request client tries to resolve the DNS, have SSL handshake, and establish a TCP connection. In an environment where these pods are frequently created and destroyed, it's important to have a low connectTimeout to avoid unnecessary delays. In a system using connection pooling, If a connection can't be established within the ",(0,i.jsx)(n.code,{children:"connectTimeout"})," period, the attempt is aborted. This prevents the client from waiting indefinitely for a connection to be established, which could lead to delays and timeouts."]}),"\n",(0,i.jsxs)(n.p,{children:["Tailcall provides a parameter named ",(0,i.jsx)(n.code,{children:"connectTimeout"})," which can be used to set the connection timeout in seconds for the HTTP client which defaults to 60 seconds. Example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:"schema\n  @upstream(\n    # highlight-start\n    connectTimeout: 10\n    # highlight-end\n  ) {\n  query: Query\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In summary, the key to maximizing HTTP client performance lies in understanding the underlying protocols and thoughtful configuration of client settings through test. By doing so, developers can ensure efficient, robust, and high-performing client-server communication, essential for the smooth operation of modern web applications."})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>r});var i=t(7294);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);